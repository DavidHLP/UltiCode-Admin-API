# Redis Commons - æœ€ä½³å®è·µ

## ğŸ—ï¸ è¿æ¥æ± ç®¡ç†

### è¿æ¥æ± é…ç½®ä¼˜åŒ–

```yaml
spring:
  data:
    redis:
      lettuce:
        pool:
          # è¿æ¥æ± æœ€å¤§è¿æ¥æ•°
          max-active: 20
          # è¿æ¥æ± æœ€å¤§ç©ºé—²è¿æ¥æ•°
          max-idle: 10
          # è¿æ¥æ± æœ€å°ç©ºé—²è¿æ¥æ•°
          min-idle: 5
          # è¿æ¥æ± æœ€å¤§é˜»å¡ç­‰å¾…æ—¶é—´
          max-wait: 2000ms
        # å…³é—­è¶…æ—¶æ—¶é—´
        shutdown-timeout: 100ms
      # è¿æ¥è¶…æ—¶æ—¶é—´
      connect-timeout: 2000ms
      # è¯»å–è¶…æ—¶æ—¶é—´
      timeout: 3000ms
```

### è¿æ¥æ± ç›‘æ§

```java
@Component
public class RedisConnectionMonitor {

    @Autowired
    private LettuceConnectionFactory connectionFactory;

    @Scheduled(fixedRate = 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void monitorConnectionPool() {
        GenericObjectPool<?> pool = connectionFactory.getPool();
        if (pool != null) {
            log.info("Redisè¿æ¥æ± çŠ¶æ€ - æ´»è·ƒè¿æ¥: {}, ç©ºé—²è¿æ¥: {}, ç­‰å¾…çº¿ç¨‹: {}",
                pool.getNumActive(), pool.getNumIdle(), pool.getNumWaiters());
        }
    }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. é”®è®¾è®¡åŸåˆ™

```java
public class RedisKeyDesignPractice {

    // âœ… å¥½çš„é”®è®¾è®¡
    private static final String USER_PREFIX = "user:";
    private static final String SESSION_PREFIX = "session:";
    private static final String CACHE_PREFIX = "cache:";

    public String buildUserKey(Long userId) {
        return USER_PREFIX + "info:" + userId;
    }

    // âœ… ä½¿ç”¨åˆ†éš”ç¬¦ä¾¿äºç®¡ç†
    public String buildCacheKey(String module, String function, String id) {
        return CACHE_PREFIX + module + ":" + function + ":" + id;
    }

    // âŒ é¿å…çš„é”®è®¾è®¡
    // è¿‡é•¿çš„é”®åï¼šuser:profile:detailed:information:with:all:fields:123
    // åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼šuser info 123, user\ninfo\t123
    // æ²¡æœ‰è§„èŒƒï¼šuserInfo123, user_info_123, UserInfo123
}
```

### 2. æ‰¹é‡æ“ä½œä¼˜åŒ–

```java
@Service
public class BatchOperationPractice {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * æ‰¹é‡è·å–ä¼˜åŒ–
     */
    public Map<String, UserInfo> batchGetUsers(List<Long> userIds) {
        if (userIds.isEmpty()) {
            return Collections.emptyMap();
        }

        // æ„å»ºé”®åˆ—è¡¨
        List<String> keys = userIds.stream()
            .map(id -> "user:info:" + id)
            .collect(Collectors.toList());

        // æ‰¹é‡è·å–
        List<Object> values = redisUtils.strings().multiGet(keys);

        // ç»„è£…ç»“æœ
        Map<String, UserInfo> result = new HashMap<>();
        for (int i = 0; i < keys.size(); i++) {
            if (values.get(i) != null) {
                result.put(keys.get(i), (UserInfo) values.get(i));
            }
        }

        return result;
    }

    /**
     * åˆ†æ‰¹å¤„ç†å¤§é‡æ•°æ®
     */
    public void batchProcessLargeDataset(List<String> largeDataset) {
        int batchSize = 100;

        for (int i = 0; i < largeDataset.size(); i += batchSize) {
            int end = Math.min(i + batchSize, largeDataset.size());
            List<String> batch = largeDataset.subList(i, end);

            // å¤„ç†å•ä¸ªæ‰¹æ¬¡
            processBatch(batch);

            // é¿å…Redisè¿‡è½½ï¼Œé€‚å½“ä¼‘æ¯
            if (end < largeDataset.size()) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    private void processBatch(List<String> batch) {
        Map<String, Object> batchData = new HashMap<>();
        for (String data : batch) {
            batchData.put("data:" + data, processData(data));
        }
        redisUtils.strings().multiSet(batchData);
    }
}
```

### 3. å†…å­˜ä½¿ç”¨ä¼˜åŒ–

```java
@Service
public class MemoryOptimizationPractice {

    /**
     * ä½¿ç”¨è¿‡æœŸæ—¶é—´é¿å…å†…å­˜æ³„æ¼
     */
    public void setWithTtl(String key, Object value) {
        // ä¸ºæ‰€æœ‰ç¼“å­˜è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´
        redisUtils.strings().set(key, value, Duration.ofHours(2));
    }

    /**
     * ä½¿ç”¨Hashç»“æ„ä¼˜åŒ–å°å¯¹è±¡å­˜å‚¨
     */
    public void optimizeSmallObjectStorage(String userId, Map<String, String> userFields) {
        String userKey = "user:hash:" + userId;

        // ä½¿ç”¨Hashè€Œä¸æ˜¯å¤šä¸ªStringé”®
        redisUtils.hashes().hmset(userKey, userFields);
        redisUtils.strings().expire(userKey, Duration.ofDays(1));
    }

    /**
     * æ¸…ç†è¿‡æœŸæ•°æ®
     */
    @Scheduled(cron = "0 0 2 * * ?") // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
    public void cleanupExpiredData() {
        String pattern = "temp:*";
        Set<String> keys = redisUtils.strings().scanKeys(pattern);

        if (!keys.isEmpty()) {
            Long deletedCount = redisUtils.strings().delete(keys.toArray(new String[0]));
            log.info("æ¸…ç†ä¸´æ—¶æ•°æ® {} æ¡", deletedCount);
        }
    }
}
```

## ğŸ”’ åˆ†å¸ƒå¼é”æœ€ä½³å®è·µ

### 1. é”ç²’åº¦æ§åˆ¶

```java
@Service
public class LockGranularityPractice {

    /**
     * ç»†ç²’åº¦é” - æ¨è
     */
    public void processOrderItem(Long orderId, Long itemId) {
        String lockKey = "order:item:lock:" + orderId + ":" + itemId;

        redisUtils.locks().executeWithLock(lockKey, () -> {
            // åªé”å®šç‰¹å®šè®¢å•çš„ç‰¹å®šå•†å“
            processSpecificOrderItem(orderId, itemId);
            return null;
        });
    }

    /**
     * ç²—ç²’åº¦é” - é¿å…
     */
    public void processOrderBad(Long orderId) {
        String lockKey = "order:lock"; // é”å®šæ‰€æœ‰è®¢å•

        redisUtils.locks().executeWithLock(lockKey, () -> {
            processOrder(orderId);
            return null;
        });
    }

    /**
     * å±‚çº§é”ç­–ç•¥
     */
    public void processWithHierarchicalLock(String userId, String resourceId) {
        // å…ˆè·å–ç”¨æˆ·çº§é”
        String userLock = "user:lock:" + userId;

        redisUtils.locks().executeWithLock(userLock, Duration.ofSeconds(5),
            Duration.ofSeconds(30), () -> {
                // å†è·å–èµ„æºçº§é”
                String resourceLock = "resource:lock:" + resourceId;

                return redisUtils.locks().executeWithLock(resourceLock,
                    Duration.ofSeconds(2), Duration.ofSeconds(10), () -> {
                        processUserResource(userId, resourceId);
                        return null;
                    });
            });
    }
}
```

### 2. é”è¶…æ—¶ä¸é‡è¯•ç­–ç•¥

```java
@Service
public class LockTimeoutPractice {

    /**
     * åˆç†çš„é”è¶…æ—¶é…ç½®
     */
    public void lockTimeoutExample() {
        // å¿«é€Ÿæ“ä½œï¼šçŸ­ç­‰å¾…æ—¶é—´ï¼ŒçŸ­æŒæœ‰æ—¶é—´
        redisUtils.locks().executeWithLock("quick:lock",
            Duration.ofSeconds(1),   // ç­‰å¾…1ç§’
            Duration.ofSeconds(5),   // æŒæœ‰5ç§’
            this::quickOperation);

        // å¤æ‚æ“ä½œï¼šé•¿ç­‰å¾…æ—¶é—´ï¼Œé•¿æŒæœ‰æ—¶é—´
        redisUtils.locks().executeWithLock("complex:lock",
            Duration.ofSeconds(10),  // ç­‰å¾…10ç§’
            Duration.ofMinutes(2),   // æŒæœ‰2åˆ†é’Ÿ
            this::complexOperation);
    }

    /**
     * æŒ‡æ•°é€€é¿é‡è¯•
     */
    public String retryWithBackoff(String lockKey, int maxRetries) {
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return redisUtils.locks().executeWithLock(lockKey,
                    Duration.ofSeconds(1), Duration.ofSeconds(30), () -> {
                        return performCriticalOperation();
                    });
            } catch (Exception e) {
                if (attempt < maxRetries) {
                    // æŒ‡æ•°é€€é¿ï¼š100ms, 200ms, 400ms, 800ms...
                    long backoffMs = (long) (100 * Math.pow(2, attempt - 1));
                    try {
                        Thread.sleep(Math.min(backoffMs, 2000)); // æœ€å¤šç­‰å¾…2ç§’
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
        throw new RuntimeException("é‡è¯•åä»ç„¶å¤±è´¥");
    }
}
```

## ğŸ’¾ ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

### 1. ç¼“å­˜ç©¿é€é˜²æŠ¤

```java
@Service
public class CachePenetrationProtection {

    /**
     * ä½¿ç”¨ç©ºå€¼ç¼“å­˜é˜²æ­¢ç¼“å­˜ç©¿é€
     */
    @RedisCacheable(
        key = "'user:info:' + #userId",
        ttl = 300, // ç©ºå€¼ç¼“å­˜è¾ƒçŸ­æ—¶é—´
        cacheNullValues = true
    )
    public User getUserWithNullProtection(Long userId) {
        User user = userRepository.findById(userId);
        // å³ä½¿userä¸ºnullä¹Ÿä¼šè¢«ç¼“å­˜ï¼Œé˜²æ­¢é‡å¤æŸ¥è¯¢æ•°æ®åº“
        return user;
    }

    /**
     * å¸ƒéš†è¿‡æ»¤å™¨é˜²æŠ¤
     */
    @Component
    public class BloomFilterProtection {

        private final BloomFilter<Long> userIdFilter;

        public BloomFilterProtection() {
            // é¢„æœŸ100ä¸‡ç”¨æˆ·ï¼Œ1%è¯¯åˆ¤ç‡
            this.userIdFilter = BloomFilter.create(Funnels.longFunnel(), 1000000, 0.01);
        }

        public User getUserWithBloomFilter(Long userId) {
            // å…ˆæ£€æŸ¥å¸ƒéš†è¿‡æ»¤å™¨
            if (!userIdFilter.mightContain(userId)) {
                return null; // ç¡®å®šä¸å­˜åœ¨
            }

            // å¯èƒ½å­˜åœ¨ï¼Œç»§ç»­æŸ¥è¯¢ç¼“å­˜å’Œæ•°æ®åº“
            return getUserFromCacheOrDb(userId);
        }

        @PostConstruct
        public void initBloomFilter() {
            // åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨
            List<Long> existingUserIds = userRepository.findAllUserIds();
            existingUserIds.forEach(userIdFilter::put);
        }
    }
}
```

### 2. ç¼“å­˜é›ªå´©é˜²æŠ¤

```java
@Service
public class CacheAvalancheProtection {

    private final Random random = new Random();

    /**
     * éšæœºTTLé˜²æ­¢ç¼“å­˜é›ªå´©
     */
    public void setCacheWithRandomTtl(String key, Object value, Duration baseTtl) {
        // åœ¨åŸºç¡€TTLä¸Šéšæœºå¢åŠ 0-20%çš„æ—¶é—´
        long randomOffset = (long) (baseTtl.toMillis() * random.nextDouble() * 0.2);
        Duration finalTtl = baseTtl.plus(Duration.ofMillis(randomOffset));

        redisUtils.strings().set(key, value, finalTtl);
    }

    /**
     * å¤šçº§ç¼“å­˜é˜²æŠ¤
     */
    @Service
    public class MultiLevelCache {

        private final CaffeineCache localCache;

        public Object getFromMultiLevelCache(String key) {
            // L1: æœ¬åœ°ç¼“å­˜
            Object value = localCache.getIfPresent(key);
            if (value != null) {
                return value;
            }

            // L2: Redisç¼“å­˜
            value = redisUtils.strings().get(key, Object.class);
            if (value != null) {
                localCache.put(key, value);
                return value;
            }

            // L3: æ•°æ®åº“ï¼ˆå¸¦é”é˜²æ­¢å¹¶å‘æŸ¥è¯¢ï¼‰
            return redisUtils.locks().executeWithLock("db:lock:" + key, () -> {
                // åŒé‡æ£€æŸ¥
                Object dbValue = redisUtils.strings().get(key, Object.class);
                if (dbValue != null) {
                    return dbValue;
                }

                // ä»æ•°æ®åº“æŸ¥è¯¢
                dbValue = queryFromDatabase(key);
                if (dbValue != null) {
                    // æ›´æ–°å„çº§ç¼“å­˜
                    setCacheWithRandomTtl(key, dbValue, Duration.ofHours(1));
                    localCache.put(key, dbValue);
                }

                return dbValue;
            });
        }
    }
}
```

### 3. ç¼“å­˜å‡»ç©¿é˜²æŠ¤

```java
@Service
public class CacheBreakdownProtection {

    /**
     * ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢ç¼“å­˜å‡»ç©¿
     */
    public Object getHotDataWithLock(String key) {
        // å…ˆå°è¯•ä»ç¼“å­˜è·å–
        Object value = redisUtils.strings().get(key, Object.class);
        if (value != null) {
            return value;
        }

        // ç¼“å­˜æœªå‘½ä¸­ï¼Œä½¿ç”¨é”ä¿æŠ¤
        String lockKey = "rebuild:lock:" + key;

        return redisUtils.locks().executeWithLockOrFallback(lockKey,
            Duration.ofSeconds(5), Duration.ofSeconds(30),
            // ä¸»è¦æ“ä½œï¼šé‡å»ºç¼“å­˜
            () -> {
                // åŒé‡æ£€æŸ¥
                Object cachedValue = redisUtils.strings().get(key, Object.class);
                if (cachedValue != null) {
                    return cachedValue;
                }

                // ä»æ•°æ®æºé‡å»ºç¼“å­˜
                Object freshValue = loadDataFromSource(key);
                if (freshValue != null) {
                    redisUtils.strings().set(key, freshValue, Duration.ofHours(2));
                }
                return freshValue;
            },
            // é™çº§æ“ä½œï¼šè¿”å›é»˜è®¤å€¼æˆ–æ—§æ•°æ®
            () -> {
                log.warn("æ— æ³•è·å–é”é‡å»ºç¼“å­˜ï¼Œè¿”å›é»˜è®¤å€¼: {}", key);
                return getDefaultValue(key);
            });
    }

    /**
     * å¼‚æ­¥åˆ·æ–°çƒ­ç‚¹æ•°æ®
     */
    @Scheduled(fixedRate = 300000) // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void refreshHotData() {
        List<String> hotKeys = getHotDataKeys();

        // å¹¶è¡Œåˆ·æ–°çƒ­ç‚¹æ•°æ®
        CompletableFuture<?>[] futures = hotKeys.stream()
            .map(key -> CompletableFuture.runAsync(() -> {
                try {
                    Object freshData = loadDataFromSource(key);
                    if (freshData != null) {
                        redisUtils.strings().set(key, freshData, Duration.ofHours(2));
                    }
                } catch (Exception e) {
                    log.error("åˆ·æ–°çƒ­ç‚¹æ•°æ®å¤±è´¥: {}", key, e);
                }
            }))
            .toArray(CompletableFuture[]::new);

        CompletableFuture.allOf(futures).join();
    }
}
```

## ğŸ” ç›‘æ§ä¸å‘Šè­¦

### 1. æ€§èƒ½ç›‘æ§

```java
@Component
public class RedisPerformanceMonitor {

    private final MeterRegistry meterRegistry;
    private final Timer.Sample sample;

    @EventListener
    public void handleRedisOperation(RedisOperationEvent event) {
        // è®°å½•æ“ä½œå»¶è¿Ÿ
        Timer.builder("redis.operation.duration")
            .tag("operation", event.getOperation())
            .tag("success", String.valueOf(event.isSuccess()))
            .register(meterRegistry)
            .record(event.getDuration(), TimeUnit.MILLISECONDS);

        // è®°å½•æ…¢æŸ¥è¯¢
        if (event.getDuration() > 1000) {
            log.warn("Redisæ…¢æ“ä½œ: {} è€—æ—¶ {}ms", event.getOperation(), event.getDuration());
        }
    }

    /**
     * å¥åº·æ£€æŸ¥
     */
    @HealthIndicator("redis")
    public Health checkRedisHealth() {
        try {
            String testKey = "health:check:" + System.currentTimeMillis();
            redisUtils.strings().set(testKey, "ok", Duration.ofSeconds(10));
            String result = redisUtils.strings().getString(testKey);
            redisUtils.strings().delete(testKey);

            if ("ok".equals(result)) {
                return Health.up()
                    .withDetail("status", "å¯ç”¨")
                    .withDetail("responseTime", "æ­£å¸¸")
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("status", "ä¸å¯ç”¨")
                .withDetail("error", e.getMessage())
                .build();
        }

        return Health.unknown().build();
    }
}
```

### 2. å¼‚å¸¸å¤„ç†

```java
@Component
public class RedisExceptionHandler {

    /**
     * å…¨å±€å¼‚å¸¸å¤„ç†
     */
    @EventListener
    public void handleRedisException(RedisExceptionEvent event) {
        Exception exception = event.getException();

        if (exception instanceof RedisConnectionFailureException) {
            // è¿æ¥å¼‚å¸¸
            log.error("Redisè¿æ¥å¤±è´¥", exception);
            triggerAlert("Redisè¿æ¥å¼‚å¸¸", exception.getMessage());

        } else if (exception instanceof QueryTimeoutException) {
            // è¶…æ—¶å¼‚å¸¸
            log.error("Redisæ“ä½œè¶…æ—¶", exception);
            triggerAlert("Redisæ“ä½œè¶…æ—¶", exception.getMessage());

        } else if (exception instanceof RedisCommandExecutionException) {
            // å‘½ä»¤æ‰§è¡Œå¼‚å¸¸
            log.error("Rediså‘½ä»¤æ‰§è¡Œå¤±è´¥", exception);
        }
    }

    /**
     * ç†”æ–­å™¨æ¨¡å¼
     */
    @Component
    public class RedisCircuitBreaker {

        private final CircuitBreaker circuitBreaker;

        public RedisCircuitBreaker() {
            this.circuitBreaker = CircuitBreaker.ofDefaults("redis");
            circuitBreaker.getEventPublisher()
                .onStateTransition(event ->
                    log.info("Redisç†”æ–­å™¨çŠ¶æ€å˜æ›´: {} -> {}",
                        event.getStateTransition().getFromState(),
                        event.getStateTransition().getToState()));
        }

        public <T> T executeWithCircuitBreaker(Supplier<T> operation, Supplier<T> fallback) {
            return circuitBreaker.executeSupplier(
                Decorators.ofSupplier(operation).withFallback(fallback));
        }
    }
}
```

é€šè¿‡éµå¾ªè¿™äº›æœ€ä½³å®è·µï¼Œå¯ä»¥ç¡®ä¿ Redis Commons åœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„é«˜æ€§èƒ½ã€é«˜å¯ç”¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
