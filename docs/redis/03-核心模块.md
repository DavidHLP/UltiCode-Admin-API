# Redis Commons - æ ¸å¿ƒæ¨¡å—

## ğŸ¢ ä»£ç ç»“æ„æ¦‚è§ˆ

Redis Commons é‡‡ç”¨æ¸…æ™°çš„æ¨¡å—åŒ–æ¶æ„ï¼ŒæŒ‰åŠŸèƒ½èŒè´£åˆ’åˆ†ä¸ºä¸åŒçš„åŒ…å’Œç±»ï¼Œç¡®ä¿ä»£ç çš„é«˜å†…èšä½è€¦åˆã€‚

```
src/main/java/com/david/redis/commons/
â”œâ”€â”€ annotation/                  # æ³¨è§£å®šä¹‰
â”‚   â”œâ”€â”€ RedisCacheable.java     # ç¼“å­˜æ³¨è§£
â”‚   â”œâ”€â”€ RedisEvict.java         # ç¼“å­˜æ¸…é™¤æ³¨è§£
â”‚   â””â”€â”€ RedisTransactional.java # äº‹åŠ¡æ³¨è§£
â”œâ”€â”€ aspect/                      # AOP åˆ‡é¢
â”‚   â”œâ”€â”€ CacheAspect.java        # ç¼“å­˜åˆ‡é¢
â”‚   â””â”€â”€ TransactionAspect.java  # äº‹åŠ¡åˆ‡é¢
â”œâ”€â”€ config/                      # é…ç½®ç±»
â”‚   â”œâ”€â”€ RedisCommonsAutoConfiguration.java
â”‚   â”œâ”€â”€ RedisConfig.java
â”‚   â””â”€â”€ RedissonConfig.java
â”œâ”€â”€ core/                        # æ ¸å¿ƒåŠŸèƒ½
â”‚   â”œâ”€â”€ RedisUtils.java         # é—¨é¢ç±»
â”‚   â”œâ”€â”€ cache/                  # ç¼“å­˜æ ¸å¿ƒ
â”‚   â”œâ”€â”€ lock/                   # åˆ†å¸ƒå¼é”
â”‚   â”œâ”€â”€ operations/             # æ•°æ®æ“ä½œ
â”‚   â””â”€â”€ transaction/            # äº‹åŠ¡ç®¡ç†
â”œâ”€â”€ enums/                      # æšä¸¾å®šä¹‰
â”œâ”€â”€ exception/                  # å¼‚å¸¸å®šä¹‰
â”œâ”€â”€ manager/                    # ç®¡ç†å™¨ç±»
â”œâ”€â”€ monitor/                    # ç›‘æ§ç›¸å…³
â””â”€â”€ properties/                 # é…ç½®å±æ€§
```

## ğŸ¯ æ ¸å¿ƒæ¨¡å—ç±»å›¾

### é—¨é¢å±‚è®¾è®¡

```mermaid
classDiagram
    class RedisUtils {
        -RedisTemplate~String,Object~ redisTemplate
        -RedisStringOperations stringOperations
        -RedisHashOperations hashOperations
        -RedisListOperations listOperations
        -RedisSetOperations setOperations
        -RedisZSetOperations zSetOperations
        -RedisLockOperations lockOperations
        -RedisTransactionOperations transactionOperations

        +strings() RedisStringOperations
        +hashes() RedisHashOperations
        +lists() RedisListOperations
        +sets() RedisSetOperations
        +zsets() RedisZSetOperations
        +locks() RedisLockOperations
        +tx() RedisTransactionOperations
    }

    class RedisStringOperations {
        <<interface>>
        +set(key, value)
        +set(key, value, timeout)
        +get(key, clazz) T
        +getString(key) String
        +delete(key) Boolean
        +delete(keys...) Long
        +expire(key, timeout) Boolean
        +hasKey(key) Boolean
        +multiGet(keys) List~Object~
        +multiSet(keyValues)
    }

    class RedisStringOperationsImpl {
        -RedisTemplate redisTemplate
        -RedisTransactionManager transactionManager
        -RedisOperationExecutor executor
        -RedisResultProcessor resultProcessor
        -RedisLoggerHelper loggerHelper

        +set(key, value)
        +get(key, clazz) T
        +delete(key) Boolean
        +expire(key, timeout) Boolean
        +multiGet(keys) List~Object~
    }

    RedisUtils --> RedisStringOperations
    RedisStringOperations <|.. RedisStringOperationsImpl
    RedisUtils --> RedisHashOperations
    RedisUtils --> RedisListOperations
    RedisUtils --> RedisSetOperations
    RedisUtils --> RedisZSetOperations
    RedisUtils --> RedisLockOperations
    RedisUtils --> RedisTransactionOperations
```

### åˆ†å¸ƒå¼é”æ¨¡å—

```mermaid
classDiagram
    class DistributedLockManager {
        -RedissonClient redissonClient
        -RedisCommonsProperties properties

        +tryLock(lockKey, waitTime, leaseTime) RedisLock
        +tryLock(lockKey) RedisLock
        +executeWithLock(lockKey, action) T
        +executeWithLockRetry(lockKey, action) T
        +executeWithLockOrFallback(lockKey, action, fallback) T
        +isLockExists(lockKey) boolean
        +forceUnlock(lockKey) boolean
        -buildLockKey(lockKey) String
        -validateLockParameters(lockKey, waitTime, leaseTime)
    }

    class RedisLock {
        <<interface>>
        +isLocked() boolean
        +isHeldByCurrentThread() boolean
        +unlock()
        +forceUnlock()
        +remainTimeToLive() long
        +close()
    }

    class RedisLockImpl {
        -RLock rLock
        -String lockKey

        +isLocked() boolean
        +isHeldByCurrentThread() boolean
        +unlock()
        +forceUnlock()
        +remainTimeToLive() long
        +close()
    }

    class RedisLockOperations {
        <<interface>>
        +tryLock(key, waitTime, leaseTime, callback) T
        +tryLock(key, callback) T
        +executeCriticalSection(key, action) T
        +checkLockStatus(key) boolean
    }

    class RedisLockOperationsImpl {
        -RedisTemplate redisTemplate
        -DistributedLockManager lockManager
        -RedissonClient redissonClient

        +tryLock(key, waitTime, leaseTime, callback) T
        +executeCriticalSection(key, action) T
        +checkLockStatus(key) boolean
    }

    DistributedLockManager --> RedisLock
    RedisLock <|.. RedisLockImpl
    RedisLockOperations <|.. RedisLockOperationsImpl
    RedisLockOperationsImpl --> DistributedLockManager
```

### ç¼“å­˜æ³¨è§£ä¸åˆ‡é¢æ¨¡å—

```mermaid
classDiagram
    class RedisCacheable {
        <<annotation>>
        +key() String
        +ttl() long
        +condition() String
        +type() Class
        +cacheNullValues() boolean
        +warmUp() boolean
        +batchSize() int
        +updateStrategy() UpdateStrategy
        +levels() CacheLevel[]
        +enableMetrics() boolean
        +refreshThreshold() double
    }

    class RedisEvict {
        <<annotation>>
        +keys() String[]
        +allEntries() boolean
        +condition() String
        +beforeInvocation() boolean
        +keyPrefix() String
    }

    class CacheAspect {
        -RedisUtils redisUtils
        -CacheKeyGenerator keyGenerator
        -CacheConditionEvaluator conditionEvaluator
        -BatchOperationManager batchManager
        -CacheWarmUpManager warmUpManager
        -CacheMetricsCollector metricsCollector

        +handleCacheable(joinPoint, annotation) Object
        +handleEvict(joinPoint, annotation) Object
        -generateCacheKey(annotation, method, args) String
        -getCachedValue(key, type) Object
        -shouldCache(annotation, method, args, result) boolean
        -cacheResult(key, result, annotation)
        -evictCache(annotation, method, args, result)
        -handleBatchCacheable(joinPoint, annotation, key, method, args) Object
    }

    class CacheKeyGenerator {
        +generateKey(expression, method, args) String
        -evaluateExpression(expression, context) String
        -buildEvaluationContext(method, args) EvaluationContext
    }

    class CacheConditionEvaluator {
        +evaluateCondition(condition, method, args, result) boolean
        -createEvaluationContext(method, args, result) EvaluationContext
    }

    CacheAspect --> RedisCacheable
    CacheAspect --> RedisEvict
    CacheAspect --> CacheKeyGenerator
    CacheAspect --> CacheConditionEvaluator
```

### äº‹åŠ¡ç®¡ç†æ¨¡å—

```mermaid
classDiagram
    class RedisTransactionManager {
        -RedisTemplate redisTemplate
        -ThreadLocal~SessionCallback~ sessionHolder

        +executeInTransaction(callback) T
        +isTransactionActive() boolean
        +beginTransaction() TransactionStatus
        +commitTransaction()
        +rollbackTransaction()
        -createTransactionCallback(operations) SessionCallback
    }

    class RedisTransactional {
        <<annotation>>
        +isolation() TransactionIsolation
        +timeout() int
        +readOnly() boolean
        +rollbackFor() Class[]
    }

    class TransactionAspect {
        -RedisTransactionManager transactionManager
        -RedisUtils redisUtils
        -CacheKeyGenerator keyGenerator
        -CacheMetricsCollector metricsCollector

        +handleTransactional(joinPoint, annotation) Object
        -executeInTransaction(joinPoint, annotation) Object
        -handleTransactionRollback(exception, annotation) boolean
    }

    class RedisTransactionOperations {
        <<interface>>
        +multi()
        +exec() List~Object~
        +discard()
        +watch(keys...)
        +unwatch()
        +execute(callback) T
    }

    class RedisTransactionOperationsImpl {
        -RedisTemplate redisTemplate
        -RedisTransactionManager transactionManager

        +multi()
        +exec() List~Object~
        +execute(callback) T
    }

    TransactionAspect --> RedisTransactional
    TransactionAspect --> RedisTransactionManager
    RedisTransactionOperations <|.. RedisTransactionOperationsImpl
    RedisTransactionOperationsImpl --> RedisTransactionManager
```

### æ‰¹é‡æ“ä½œä¸ç¼“å­˜é¢„çƒ­æ¨¡å—

```mermaid
classDiagram
    class BatchOperationManager {
        -RedisUtils redisUtils
        -int defaultBatchSize

        +batchGet(keys, type) Map~String,Object~
        +batchSet(keyValues, ttl)
        +batchDelete(keys) Long
        +batchExists(keys) Map~String,Boolean~
        -executeBatchOperation(operation, batchSize)
        -splitIntoBatches(items, batchSize) List~List~
    }

    class CacheWarmUpManager {
        -RedisUtils redisUtils
        -BatchOperationManager batchManager
        -ScheduledExecutorService scheduler

        +triggerWarmUp(pattern, priority)
        +scheduleWarmUp(pattern, delay, priority)
        +warmUpByPattern(pattern) CompletableFuture~Void~
        +cancelWarmUp(pattern)
        -executeWarmUpTask(pattern, priority)
        -loadWarmUpData(pattern) Map~String,Object~
    }

    class CacheMetricsCollector {
        -AtomicLong hitCount
        -AtomicLong missCount
        -AtomicLong errorCount
        -ConcurrentHashMap~String,ResponseTimeStats~ responseTimeStats

        +recordHit(key, responseTime)
        +recordMiss(key, responseTime)
        +recordSet(key, responseTime)
        +recordError(operation, responseTime)
        +getHitRate() double
        +getTotalOperations() long
        +getAverageResponseTime() double
        +resetMetrics()
    }

    BatchOperationManager --> RedisUtils
    CacheWarmUpManager --> RedisUtils
    CacheWarmUpManager --> BatchOperationManager
```

## ğŸ“‹ æ ¸å¿ƒæ“ä½œæ¥å£è¯¦è§£

### String æ“ä½œæ¥å£

`RedisStringOperations` æä¾›äº†å®Œæ•´çš„ Redis String ç±»å‹æ“ä½œï¼š

**åŸºç¡€æ“ä½œ**ï¼š

- `set(key, value)` - è®¾ç½®é”®å€¼å¯¹
- `set(key, value, timeout)` - è®¾ç½®å¸¦è¿‡æœŸæ—¶é—´çš„é”®å€¼å¯¹
- `get(key, clazz)` - è·å–æŒ‡å®šç±»å‹çš„å€¼
- `getString(key)` - è·å–å­—ç¬¦ä¸²å€¼

**æ‰¹é‡æ“ä½œ**ï¼š

- `multiGet(keys)` - æ‰¹é‡è·å–å¤šä¸ªé”®çš„å€¼
- `multiSet(keyValues)` - æ‰¹é‡è®¾ç½®å¤šä¸ªé”®å€¼å¯¹
- `delete(keys...)` - æ‰¹é‡åˆ é™¤é”®

**é«˜çº§æ“ä½œ**ï¼š

- `expire(key, timeout)` - è®¾ç½®è¿‡æœŸæ—¶é—´
- `hasKey(key)` - æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
- `scanKeys(pattern)` - å®‰å…¨çš„é”®æ‰«æ

### Hash æ“ä½œæ¥å£

```java
public interface RedisHashOperations {
    // åŸºç¡€æ“ä½œ
    void hset(String key, String field, Object value);
    <T> T hget(String key, String field, Class<T> clazz);
    Map<String, Object> hgetall(String key);
    Boolean hdel(String key, String... fields);

    // æ‰¹é‡æ“ä½œ
    void hmset(String key, Map<String, Object> fieldValues);
    List<Object> hmget(String key, String... fields);

    // é«˜çº§æ“ä½œ
    Boolean hexists(String key, String field);
    Set<String> hkeys(String key);
    Long hincrBy(String key, String field, long delta);
    Double hincrByFloat(String key, String field, double delta);
}
```

### List æ“ä½œæ¥å£

```java
public interface RedisListOperations {
    // æ¨å…¥æ“ä½œ
    Long lpush(String key, Object... values);
    Long rpush(String key, Object... values);

    // å¼¹å‡ºæ“ä½œ
    <T> T lpop(String key, Class<T> clazz);
    <T> T rpop(String key, Class<T> clazz);

    // èŒƒå›´æ“ä½œ
    <T> List<T> lrange(String key, long start, long end, Class<T> clazz);
    void ltrim(String key, long start, long end);

    // ç´¢å¼•æ“ä½œ
    <T> T lindex(String key, long index, Class<T> clazz);
    void lset(String key, long index, Object value);
    Long llen(String key);
}
```

### Set æ“ä½œæ¥å£

```java
public interface RedisSetOperations {
    // åŸºç¡€æ“ä½œ
    Long sadd(String key, Object... values);
    Boolean srem(String key, Object... values);
    Boolean sismember(String key, Object value);

    // é›†åˆè¿ç®—
    Set<Object> sunion(String... keys);
    Set<Object> sinter(String... keys);
    Set<Object> sdiff(String... keys);

    // éšæœºæ“ä½œ
    <T> T spop(String key, Class<T> clazz);
    <T> T srandmember(String key, Class<T> clazz);
    <T> List<T> srandmember(String key, int count, Class<T> clazz);
}
```

### ZSet æ“ä½œæ¥å£

```java
public interface RedisZSetOperations {
    // åŸºç¡€æ“ä½œ
    Boolean zadd(String key, double score, Object value);
    Boolean zrem(String key, Object... values);
    Double zscore(String key, Object value);

    // æ’åæ“ä½œ
    Long zrank(String key, Object value);
    Long zrevrank(String key, Object value);

    // èŒƒå›´æ“ä½œ
    <T> Set<T> zrange(String key, long start, long end, Class<T> clazz);
    <T> Set<T> zrevrange(String key, long start, long end, Class<T> clazz);
    <T> Set<T> zrangeByScore(String key, double min, double max, Class<T> clazz);

    // ç»Ÿè®¡æ“ä½œ
    Long zcount(String key, double min, double max);
    Long zcard(String key);
}
```

## ğŸ”§ æ”¯æ’‘ç»„ä»¶æ¨¡å—

### æ“ä½œæ‰§è¡Œå™¨

```java
@Component
public class RedisOperationExecutor {
    private final RedisLoggerHelper loggerHelper;

    public <T> T execute(String operation, Supplier<T> supplier) {
        long startTime = System.currentTimeMillis();
        try {
            T result = supplier.get();
            loggerHelper.logSuccess(operation, System.currentTimeMillis() - startTime);
            return result;
        } catch (Exception e) {
            loggerHelper.logError(operation, e, System.currentTimeMillis() - startTime);
            throw new RedisOperationException(operation, e);
        }
    }
}
```

### ç»“æœå¤„ç†å™¨

```java
@Component
public class RedisResultProcessor {

    public <T> T processResult(Object result, Class<T> targetType) {
        if (result == null) {
            return null;
        }

        if (targetType.isAssignableFrom(result.getClass())) {
            return targetType.cast(result);
        }

        return convertType(result, targetType);
    }

    @SuppressWarnings("unchecked")
    private <T> T convertType(Object source, Class<T> targetType) {
        // ç±»å‹è½¬æ¢é€»è¾‘
        if (targetType == String.class) {
            return (T) source.toString();
        }
        // ... å…¶ä»–è½¬æ¢é€»è¾‘
        throw new IllegalArgumentException("ä¸æ”¯æŒçš„ç±»å‹è½¬æ¢");
    }
}
```

### æ—¥å¿—åŠ©æ‰‹

```java
@Component
public class RedisLoggerHelper {
    private static final Logger log = LoggerFactory.getLogger(RedisLoggerHelper.class);

    public void logSuccess(String operation, long duration) {
        if (log.isDebugEnabled()) {
            log.debug("Redisæ“ä½œæˆåŠŸ - æ“ä½œ: {}, è€—æ—¶: {}ms", operation, duration);
        }
    }

    public void logError(String operation, Exception e, long duration) {
        log.error("Redisæ“ä½œå¤±è´¥ - æ“ä½œ: {}, è€—æ—¶: {}ms", operation, duration, e);
    }

    public void logSlowOperation(String operation, long duration, long threshold) {
        if (duration > threshold) {
            log.warn("Redisæ…¢æ“ä½œ - æ“ä½œ: {}, è€—æ—¶: {}ms, é˜ˆå€¼: {}ms",
                    operation, duration, threshold);
        }
    }
}
```

## ğŸ¨ è®¾è®¡æ¨¡å¼åº”ç”¨

### 1. é—¨é¢æ¨¡å¼ï¼ˆFacade Patternï¼‰

- **åº”ç”¨åœºæ™¯**ï¼š`RedisUtils` ç±»ä½œä¸ºç»Ÿä¸€é—¨é¢
- **ä¼˜åŠ¿**ï¼šç®€åŒ–å®¢æˆ·ç«¯è°ƒç”¨ï¼Œéšè—å¤æ‚çš„å­ç³»ç»Ÿ

### 2. ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰

- **åº”ç”¨åœºæ™¯**ï¼šç¼“å­˜æ›´æ–°ç­–ç•¥ã€åºåˆ—åŒ–ç­–ç•¥
- **ä¼˜åŠ¿**ï¼šçµæ´»åˆ‡æ¢ç®—æ³•å®ç°

### 3. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Method Patternï¼‰

- **åº”ç”¨åœºæ™¯**ï¼šRedisæ“ä½œçš„é€šç”¨æ‰§è¡Œæ¨¡æ¿
- **ä¼˜åŠ¿**ï¼šç»Ÿä¸€å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•

### 4. è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰

- **åº”ç”¨åœºæ™¯**ï¼šä¸ºRedisæ“ä½œæ·»åŠ äº‹åŠ¡ã€ç›‘æ§ç­‰åŠŸèƒ½
- **ä¼˜åŠ¿**ï¼šåŠ¨æ€æ‰©å±•åŠŸèƒ½ï¼Œä¸ä¿®æ”¹åŸæœ‰ä»£ç 

### 5. è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰

- **åº”ç”¨åœºæ™¯**ï¼šæ€§èƒ½æŒ‡æ ‡æ”¶é›†å’Œäº‹ä»¶é€šçŸ¥
- **ä¼˜åŠ¿**ï¼šæ¾è€¦åˆçš„äº‹ä»¶å¤„ç†æœºåˆ¶
